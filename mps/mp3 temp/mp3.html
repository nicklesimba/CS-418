<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>

<!-- *** Teapot Shader Section - includes shading, reflection, and refraction *** -->
<script id="envmap-vertex-shader" type="x-shader/x-vertex">
// Per vertex information
attribute vec4 a_position;
attribute vec3 a_normal;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;

varying vec3 v_worldPosition;
varying vec3 v_worldNormal;

void main() {
  // Calculate position
  gl_Position = u_projection * u_view * u_world * a_position;

  v_worldPosition = (u_world * a_position).xyz;

  // Orient normal vectors correctly
  v_worldNormal = mat3(u_world) * a_normal;
}
</script>
<!-- fragment shader -->
<script id="envmap-fragment-shader" type="x-shader/x-fragment">
precision mediump float;

varying vec3 v_worldPosition;
varying vec3 v_worldNormal;

uniform samplerCube u_texture;

uniform vec3 u_worldCameraPosition;

void main() {
  vec3 worldNormal = normalize(v_worldNormal);
  vec3 eyeToSurfaceDir = normalize(v_worldPosition - u_worldCameraPosition);
  vec3 direction = reflect(eyeToSurfaceDir,worldNormal);

  gl_FragColor = textureCube(u_texture, direction);
}
</script>
<script id="shader-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexNormal;
  attribute vec3 aVertexPosition;
 
  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;
  uniform mat3 uNMatrix;
  
  uniform vec3 uLightPosition;
  uniform vec3 uAmbientLightColor;
  uniform vec3 uDiffuseLightColor;
  uniform vec3 uSpecularLightColor;
  
  uniform vec3 uKAmbient;
  uniform vec3 uKDiffuse;
  uniform vec3 uKSpecular;
  uniform float uShininess;
  
  varying vec4 vColor;

  void main(void) {
  
  // Get the vertex position in eye coordinates
  vec4 vertexPositionEye4 = uMVMatrix * vec4(aVertexPosition, 1.0);
  vec3 vertexPositionEye3 = vertexPositionEye4.xyz / vertexPositionEye4.w;

  // Calculate the vector (l) to the light source
  vec3 lightEye=(vec4(uLightPosition,1)).xyz;
  vec3 vectorToLightSource = normalize(lightEye - vertexPositionEye3);
  
  // Transform the normal (n) to eye coordinates
  vec3 normalEye = normalize(uNMatrix * aVertexNormal);
  
  // Calculate n dot l for diffuse lighting
  float diffuseLightWeightning = max(dot(normalEye, 
                                  vectorToLightSource), 0.0);
                                     
  // Calculate the reflection vector (r) that is needed for specular light
  vec3 reflectionVector = normalize(reflect(-vectorToLightSource, 
                                           normalEye));
  
  // The camera in eye coordinates is located in the origin and is pointing
  // along the negative z-axis. Calculate viewVector (v) 
  // in eye coordinates as:
  // (0.0, 0.0, 0.0) - vertexPositionEye3
  vec3 viewVectorEye = -normalize(vertexPositionEye3);
  
  float rdotv = max(dot(reflectionVector, viewVectorEye), 0.0);
  
  float specularLightWeightning = pow(rdotv, uShininess);

  // Sum up all three reflection components and send to the fragment shader
  vColor = vec4(((uAmbientLightColor*uKAmbient)
              + (uDiffuseLightColor*uKDiffuse) * diffuseLightWeightning
              + ((uSpecularLightColor*uKSpecular) * specularLightWeightning)),1.0);
              
  gl_Position = uPMatrix*uMVMatrix*vec4(aVertexPosition, 1.0);
  //vColor=vec4(normalEye,1);
  }
</script>
<script id="shader-fs" type="x-shader/x-fragment">
precision mediump float;
varying vec4 vColor;
void main(void) {
      gl_FragColor = vColor;
}
</script>



<!-- *** Skybox Shader Section *** -->
<script id="skybox-vertex-shader" type="x-shader/x-vertex">
attribute vec4 a_position;
varying vec4 v_position; // We need to use the position in the fragment shader as well
void main() {
  v_position = a_position;
  gl_Position = a_position;
}
</script>
<script id="skybox-fragment-shader" type="x-shader/x-fragment">
precision mediump float;

uniform samplerCube u_skybox;
uniform mat4 u_viewDirectionProjectionInverse;

varying vec4 v_position;
void main() {
  vec4 t = u_viewDirectionProjectionInverse * v_position;
  gl_FragColor = textureCube(u_skybox, normalize(t.xyz / t.w));
}
</script>


<script src="webgl-utils.js"></script>
<script src="m4.js"></script>
<script src="primitives.js"></script>
<script src="gl-matrix-min.js"></script>
<script src="TriMesh.js"></script>  
<script src="mp3.js"></script>

<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>MP3</title>
<link type="text/css" href="webgl-tutorials.css" rel="stylesheet" />
</head>
<body onload=startup();>
<div class="description">
If this text is still here, the mp is NOT READY FOR SUBMISSION! check for unused variables, add comments everywhere. <br>
Nikhil Simha<br>
CS 418: MP3 - Environment Mapping<br>
</div>
<canvas id="canvas"></canvas>

<form id="input_form">
    <fieldset>
        <legend>Rendering Parameters</legend>
     <input type="radio" name="primitive" id="wireframe" value="wireframe"> Wireframe
     <input type="radio" name="primitive" id="polygon" id="polygon" value="polygon" checked> Polygon
     <input type="radio" name="primitive" id="wirepoly" value="wirepoly" > Polygon with Edges  
    </fieldset>
    <fieldset>
        <legend>Controls</legend>
     <emph>Euler Y:</emph> Keys A and D <br><br>
     <emph>Camera Y:</emph> Keys ArrowLeft and ArrowRight   
    </fieldset>
    Included code libraries such as m4.js are taken either from the prebuilt versions of TWGL at webglfundamentals.org or from Lab 6 code.<br>
    CSS styling (border and background) taken from webglfundamentals.org<br/>
</form>

</body>

</html>